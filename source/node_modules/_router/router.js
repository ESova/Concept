'use strict'
/* CONCEPT: Router
    A Router is a stream

    - It has maybe some control methods and initial config params
    - It takes in current URL param and maybe other stuff
    - It spits out vtree

    // @IDEA: really?
    // Component(db, engine) seems to show something different
    // ....

    // vtree can then be piped into different engines,
    // e.g. vtre2dom engine
*/
/****************************************************************************
  STACK
****************************************************************************/
const routes     = require('routes')
const singlepage = require('single-page')
const catchlinks = require('catch-links')
// const stream  = require('stream-browserify')
const stream     = require('readable-stream')

const h          = require('virtual-dom/h')
/****************************************************************************
  CUSTOM
****************************************************************************/
const defined    = require('defined')
const WINDOW     = require('global/window')

var router$      = void 0

module.exports = ROUTER

// @TODO: https://www.npmjs.com/package/stream-router

// Singleton router$
function ROUTER (db, urlRouting, dataRouting) {
  if (!router$) {
    console.log('=== Initialize router$ ===')
    var router = routes()
    urlRouting(router) // activates all routes

    var opts = {} // e.g. saving of scrollX & scrollY for each route
    catchlinks(WINDOW, singlepage(pagehandler, opts))
    function pagehandler (href, page) {
      // catchLinks(window, function cb (href) { })
      // => grab all relative anchor tags "href" attributes and fire cb(href)
      //
      // var showPage = singlePage(cb, opts)
      // => handle PUSH STATE EVENTS
      // => fires cb(href, page) once
      //   => location.href = href
      // showPage(href) => fires cb(href, page) again
      //   => location.href = href
      // href === STATE.href === db.get('href').href
      const TARGET = { href: href, page: page } // STATE.route['path'] = href
      console.log('Navigate to: ', TARGET)

      var route = router.match(href)
      // e.g. http://localhost:5000/:param1/:param2/*splat
      // route = {
      //   params  : { param1: '...', param2: '...' },
      //   splats  : ['*splat'],
      //   route   : '/',
      //   next    : function next () {}
      //   fn      : function routeHandler() {}
      // }

      // db.put('href', TARGET) // @TODO: keep history undo/redo navigation

      /***********************************************************************
        RENDER PAGE => HANDLE PAGE & STATE CHANGE
      ***********************************************************************/
      var vtree = /*vtree*/ route ? route.fn() : render404()
      //route.fn(STATE) // SINGLE RESPONSIBILITY + DRY
        // I try to only pass in the information that a route directly needs,
        // since that keeps the code less coupled to my application.
        // => maybe let the ROUTE state what it needs instead
        // => if necessary, grant permissions to routes
      router$.push(vtree)
    }
    function read () {
      // sets this._read under the hood
      // push data onto the read queue, passing null
      // will signal the end of the stream (EOF)
    }
    // sets this._read under the hood
    return router$ = new stream.Readable({ read: read, objectMode: true })
  } else {
    return router$
  }
}
///////////////////////////////////////////////////////////////////////////////
/*

 THOUGHTS:
   - maybe the router should replace "index.js"
   - maybe router should be the main entry point
   - router gets initialized with location.href or root "/"
   - then handles all the updates by piping the
     - root component for a route to the engine$
*/
// STANDARD INTERFACE ???
// module.exports = function (req, res, params) {
//     res.end('beep boop\n')
// }
// and then in the server.js I can do:
// => router.addRoute('/whatever', require('./lib/someroute.js'));
// VS.
// state && state.route // IN COMBINATION WITH:
// // e.g.
// ./SOURCE/node_modules/_router/index.js
// ./SOURCE/node_modules/_router/someroute.js
// ./SOURCE/node_modules/_router/...
// module.exports = function (msg) {
//     return function (req, res, params) {
//         res.end(msg + '\n')
//     }
// }
// and then in server.js:
// => router.addRoute('/whatever', require('./lib/someroute.js')('beep boop'))
