'use strict'
var minixhr = require('minixhr')
var padleft = require('pad-left')
var type = require('component-type')
var qery = require('qery')
var murl = require('murl')
var jmm = require('json-meta-marked')
/******************************************************************************
  CUSTOM

    @TODO: there needs to be a playground for exploring API's manually before
           wiring them up to meaningful "petkey's" in the context of current app

    @XXX: if it was switchboard already - a listener to db was enough
          the ajax updates would come in at a central location in code
          and listeners would be notified
    @TODO: crappy keys go away by using component prefixed db's everywhere
    @TODO: a mapping is required, from external world/api key's to
           internal world/pet key's
     thus: "host"+"pathname"+"params" => "petname"+(?query params?)
******************************************************************************/
var STATUS = {
  200: success,
  304: unchanged,
  401: unauthorized,
  403: notAvailable,
  404: notFound
}
/*****************************************************************************/
var esova = (function service (pattern) {
  return function api (realkey, params, next) {
    // @TODO: support POST
    var key = params.key
    var token = params.token
    if (key && !token) next(new Error('"lesson" requires "token" too'))
    var querystring = qery({ 'token': token, 'last_lesson': key })
    var hostpath = pattern({ realkey: realkey })
    var url = hostpath + querystring
    var request = { url: url, method: key ? 'POST' : 'GET' }
    next(null, request)
  }
}(murl('http://45.55.222.16/{realkey}')))
/*****************************************************************************/
var github = (function service (pattern, UNDEFINED) {
  return function api (realkey, params, next) {
    var etag = params.etag
    var token = params.token
    var querystring = qery({ 'access_token': token })
    var hostpath = pattern({ realkey: realkey })
    var url = hostpath + querystring
    var headers =  etag ? { headers: { 'If-None-Match': etag } } : UNDEFINED
    var request =  { url: url, method: 'GET' }
    if (headers) request.headers = headers
    next(null, request)
  }
}(murl('https://raw.githubusercontent.com/ESova/program/master{realkey}')))
/*****************************************************************************/
var CONTEXT = {
  'getlesson': { // petaction
    PETBASE: murl('/data/{language}/lesson/{number}/description'),
    REALBASE: murl('/lesson{number}/description.{language}.md'),
    realkey2petkey: function realkey2petkey (realkey, next) {
      next(null,this.PETBASE+(+realkey.split(this.REALBASE)[1]))
    }, // realapi2petapi
    petkey2realkey: function petkey2realkey (petkey, next) {
      next(null,this.REALBASE+padleft(petkey.split(this.PETBASE)[1],3,'0'))
    }, // petapi2realapi
    translate: getLessonKey, // ??? translator === petAction2realAction ???
    getPetKey: function (key, next) {
      next(null, this.PETBASE({number:key, language: 'rs'}))
    },
    getRealKey:function(key,next){
      next(null,this.REALBASE({number:padleft(key,3,'0'), language: 'rs'}))
    },
    // getActionCredentials // // @IDEA: retrieves token or allowance for action
    realAction: getLesson // getLessonDescription // @TODO
  }
}
/******************************************************************************
  MAIN

  @IDEA:
    - Have a spot to integrate all IO<->db
    - Wireup by connecting different API Providers serving via different tech
      - e.g. websocket, webrtc, ajax, sensors?, ...
    - listen for db.get requests, thus at least "initial subscribes"
      - e.g. db.track(...)
    - put data to db whenever updates arrive

    USE CASES / SCENARIOS:
      - @IDEA: when not new data arrived, thus no "notify" dispatched,
        - => cached value is still up2date
      - getCurrentLesson when rendering lesson page
      - getToken to signin
      - @TODO: ... fine more examples ...

******************************************************************************/
module.exports = githubapi

function githubapi (db) {
  return function api (petaction, callback) { execute(db, petaction, callback) }
}
/******************************************************************************
  HELPER - getLessonKey
******************************************************************************/
function getLessonKey (db, next/*(error, lessonKey)*/) {
  var realkey = 'last_lesson'
  db.get('esova-credentials', function (error, credentials) {
    if (error) db.get('esova-currentLesson', function (error, lesson) {
      if (error) db.put('esova-currentLesson', '0', function (error) {
        if (error) next(new Error('couldnt initialize lesson store'))
        else next(null, '0')
      })
      else next(null, lesson)
    })
    else db.get('esova-currentLesson', function (error, lesson) {
      var id = credentials.id
      if (error) esova(realkey, {id:id}, function (error, request) {
        if (error) next(new Error('lesson request failed'))
        else minixhr(request, (function (timedout) {
          var id = setTimeout(function timeout (error) {
            timedout = true
            next(error)
          }, 2500, new Error('lesson request timedout'))
          return function save (data/*, response, xhr, headers*/) {
            if (timedout) return console.error('request came in, but was slow')
            clearTimeout(id)
            if ( data.length > 100) next('lesson request remote server error')
            else db.put('esova-currentLesson', data, function (error) {
              if (error) next(new Error('couldnt save to lesson store'))
              else next(null, data)
            })
          }
        }()))
      })
      else next(null, lesson) // local cached is "THE TRUTH"
    })
  })
}
/******************************************************************************
  HELPER - isInvalid
******************************************************************************/
function isInvalid (context) {
  return !(context &&
    type(context.PETBASE) === 'function' &&
    type(context.REALBASE) === 'function' &&
    type(context.translate) === 'function' &&
    type(context.getPetKey) === 'function' &&
    type(context.getRealKey) === 'function' &&
    type(context.realAction) === 'function')
}
/******************************************************************************
  HELPER - execute
******************************************************************************/
// @TODO rewrite using http://calbackhell.com information
function execute (db, petaction, next/*(error, result)*/) {
  var CON = CONTEXT[petaction]
  if(isInvalid(CON)) next(new Error('no valid pet action given'))
  else CON.translate(db, function (error, key) {
    if (error) next(error)
    else CON.getRealKey(key, function (error, realkey) {
      if (error) next(error)
      else CON.getPetKey(key, function (error, petkey) {
        if (error) next(error)
        else CON.realAction(db, petkey, realkey, function (error, lesson) {
          if (error) next(error)
          else next(null, lesson)
        })
      })
    })
  })
}
/******************************************************************************
  HELPER - getLesson
******************************************************************************/
function getLesson (db, petkey, realkey, next/*(error, lesson)*/) {
  db.get(petkey, function (error, cache) {
    var c = cache ? JSON.parse(cache) : {}
    if (error) db.get('esova-credentials', function (error, creds) {
      // GET "lesson" anonymously or with token
      error ? req(c,{}) : req(c,{id:creds.id})
    })
    else db.get('esova-credentials', function (error, creds) {
      // CHECK for "lesson updates" using etag anonymously or with token
      error ? req(c,{etag:cache.ETag}) : req(c,{id:creds.id,etag:cache.ETag})
    })
  })
  function req (cache, params) {
    github(realkey, params, function (error, request) {
      if (error) cache ? next(null, cache.data) : next(error)
      else minixhr(request, makeHandler(db,petkey,cache,function (error,data) {
        if (error) cache ? next(null, cache.data) : next(error)
        else next(null, data)
      }))
    })
  }
}
/******************************************************************************
  HELPER - makeHandler
******************************************************************************/
function makeHandler (db, petkey, cache, callback) {
  var cData = cache ? cache.data : undefined
  return function handler (data, _, xhr, header) {
    var status = (xhr||{}).status
    var handle = STATUS[status]
    if (!handle) handle = internalError
    if (header) printRemaining(header)
    handle(db, status, petkey, cData, data, header, callback)
  }
}
/******************************************************************************
  HELPER - printRemaining
******************************************************************************/
function printRemaining (header) {
  var left  = +header["X-RateLimit-Remaining"]
  var total = +header["X-RateLimit-Limit"]
  var msg   = 'Remaining Requests: ' + left + '/' + total
  console.error(msg)
}
/******************************************************************************
  200: success
******************************************************************************/
function success (db, __, petkey, ____, data, header, cb) {
  if (data) {
    try { data = JSON.parse(data) }
    catch (e) {
      try { data = jmm.parse(data) }
      catch (e) { }
    }
    var value = JSON.stringify({ ETag : header.ETag, data : data })
    db.put(petkey, value, function (error) {
      if (error) cb(error, null)
      else cb(null, data)
    })
  } else cb(null, data)
}
/******************************************************************************
  304: unchanged
******************************************************************************/
function unchanged (db, __, ___, cachedData, ____, _____, cb) {
  cb(null, cachedData)
}
/******************************************************************************
  401: unauthorized
******************************************************************************/
function unauthorized (db, status, _, __, ___, ____, callback) {
  var e = new Error('status: '+status+' (auth token invalid)')
  e.status = status
  callback(e)
}
/******************************************************************************
  404: notFound
******************************************************************************/
function notFound (db, status, _, __, ___, ____, callback) {
  var e = new Error('status: '+status+' (not found)')
  e.status = status
  callback(e)
}
/******************************************************************************
  403: notAvailable
******************************************************************************/
function notAvailable (db, status, _, __, ___, ____, callback) {
  var e = new Error('status: '+status+' (not available)')
  e.msg = 'Service temporarily not available - try again in one hour'
  e.status = status
  callback(e)
}
/******************************************************************************
  ???/500: internalError
******************************************************************************/
function internalError (db, status, _, __, ___, ____, callback) {
  var e = new Error('status: '+status||500+' (Internal Error)')
  e.status = status
  callback(e)
}
