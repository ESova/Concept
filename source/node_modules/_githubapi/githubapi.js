'use strict'
var minixhr = require('minixhr')
/************************************************
  CUSTOM
************************************************/
var STATUS = {
  200: success,
  304: unchanged,
  401: unauthorized,
  403: notAvailable,
  404: notFound,
  'ETIMEDOUT': timedout
}
var host = 'https://api.github.com/'
var param = '?access_token='
var ACTIONS = {
  'program': 'repos/ESova/program/contents'
}
/************************************************
  MAIN
************************************************/
module.exports = githubapi

function githubapi (db) {
  return api
  function api (action, cb) {
    var pathname = ACTIONS[action]
    if(!pathname) cb(new Error('no valid action given'))
    else db.get('esova-token', function (error, token) {
      db.get('gAction/'+action, function (error, cache) {
        cache = cache ? JSON.parse(cache) : {}
        var request = token ?
          buildAuthedRequest(pathname, token, cache)
          : buildUnauthedRequest(pathname, cache)
        var handler = makeHandler(db, action, cache, cb)
        minixhr(request, handler)
      })
    })
  }
}
/************************************************
  HANDLER - 200: success
************************************************/
function success (_, db, __, action, ____, data, header, cb) {
  data = JSON.parse(data)
  var value = JSON.stringify({
    ETag   : header.ETag,
    data   : data,
    action : action
  })
  db.put('gAction/'+action, value, function (error) {
    if (error) cb(error, null)
    else cb(null, data)
  })
}
/************************************************
  HANDLER - 304: unchanged
************************************************/
function unchanged (_, db, __, ___, cache, ____, _____, cb) {
  cb(null, cache)
}
/************************************************
  HANDLER - ETIMEDOUT: timedout
************************************************/
function timedout (error, db, __, ___, cache, ____, _____, cb) {
  if (cache) cb(null, cache.data)
  else cb(error, null)
}
/************************************************
  HANDLER - 401: unauthorized
************************************************/
// @TODO: Just make sure to catch 401 Unauthorized error on requests
// in case the token is no longer valid and ask the user to log in again.
function unauthorized (error, db, status, _, __, ___, ____, callback) {
  var e = error || new Error('status: '+status+' (auth token invalid)')
  e.status = status
  callback(e)
}
/************************************************
  HANDLER - 404: notFound
************************************************/
function notFound (error, db, status, _, __, ___, ____, callback) {
  var e = error || new Error('status: '+status+' (not found)')
  e.status = status
  callback(e)
}
/************************************************
  HANDLER - 403: notAvailable
************************************************/
function notAvailable (error, db, status, _, __, ___, ____, callback) {
  var e = error || new Error('status: '+status+' (not available)')
  e.msg = 'Service temporarily not available - try again in one hour'
  e.status = status
  callback(e)
}
/************************************************
  HANDLER - ???/500: internalError
************************************************/
function internalError (error, db, status, _, __, ___, ____, callback) {
  var e = error || new Error('status: '+status||500+' (Internal Error)')
  e.status = status
  callback(e)
}
/************************************************
  printRemaining
************************************************/
function printRemaining (header) {
  var left  = +header["X-RateLimit-Remaining"]
  var total = +header["X-RateLimit-Limit"]
  var msg   = 'Remaining Requests: ' + left + '/' + total
  console.error(msg)
}
/************************************************
  buildAuthedRequest
************************************************/
function buildAuthedRequest (pathname, token, cache) {
  var eTag = cache.ETag
  return {
    url: host + pathname + param + token,
    timeout: eTag ? '9999' : null,
    header: {
      "If-None-Match"    : eTag || ''
      // 'X-Requested-With' :'XMLHttpRequest',
      // authorization: 'token ' + token,
      // 'Content-Type': 'application/x-www-form-urlencoded'
      // 'Content-Type': 'application/json'
    }
  }
}
/************************************************
  buildUnauthedRequest
************************************************/
function buildUnauthedRequest (pathname, cache) {
  throw new Error('@TODO: not implemented yet!')
  // var eTag = cache.ETag
  // return {
  //   url: host + action + param + token,
  //   timeout: eTag ? '9999' : null,
  //   header: {
  //     "If-None-Match"    : eTag || ''
  //     // 'X-Requested-With' :'XMLHttpRequest',
  //     // authorization: 'token ' + token,
  //     // 'Content-Type': 'application/x-www-form-urlencoded'
  //     // 'Content-Type': 'application/json'
  //   }
  // }
}
/************************************************
  makeHandler
************************************************/
function makeHandler (db, action, cache, callback) {
  return function handler (error, data, _, xhr, header) {
    var status = (xhr||{}).status||(error||{}).code
    var handle = STATUS[status]
    if (!handle) handle = internalError
    if (header) printRemaining(header)
    handle(error, db, status, action, cache, data, header, callback)
  }
}
